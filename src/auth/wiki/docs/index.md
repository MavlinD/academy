### Определение 
**Аутентификационный микросервис, высокопроизводительный, легкий и готовый к использованию**.  

Юнит стандартизирован до спецификации [OpenAPI v3](https://spec.openapis.org/oas/v3.0.3) и представляет собой типичный, классический [REST API].<br>[Swagger UI] является неотъемлемой частью основного кода.

!!! info "Сервис обеспечивает только аутентификацию, авторизация запросов остаётся задачей основного сервиса и реализовать её предлагается на основе групп, как это принято, например, в операционных системах." 

!!! attention "Поддерживается только [JWT] аутентификация по ассиметричным алгоритмам. <br>Предоставляется пара токенов, **access & refresh**."

### Алгоритм работы

Предлагается следующая схема: Клиент запрашивает аутентификационный токен, получив его отправляет запросы к основному сервису, последний [верифицирует](structure/#верификация-токенов) полученный токен (в данном случае на публичном ключе auth сервиса, не обращась к последнему).  
Если токен валиден, то основной сервис находит или не находит нужную группу в списке групп пользователя и принимает соответственное решение об авторизации запроса.
Нагрузка токена содержит список групп пользователя.   
Таким образом основному сервису не требуется взаимодействовать с auth юнитом, не требуется и хранить реестр пользователей у себя.  
!!! info "Вообще ни auth, ни основной сервис не хранят состояние пользователя - реализуется основной принцип [REST API].<br>Любой и каждый запрос самодостаточен."  
!!! attention "Администратор основного сервиса должен иметь учётную запись суперпользователя."  
В принципе всё, как обычно, за исключением того, что запрос на аутентификацию отправляется не к своей БД, а к стороннему, доверенному сервису.

### Выбор БД
```sh
# определяет тип СуБД
>>DBS_ENGINE = sqlite|postgres
```

### Развертывание

```shell
# Клонируем репо
git clone 
cd auth-v2
cp template.env .env
# Заполняем файл с переменными окружения
```
#### если [PostgreSQL]:
```shell
# создаём папку для файлов БД имя папки указанной ниже
# формируется как $DBS/${POSTGRES_DB_FOLDER}${SUFFIX} 
mkdir dbs/pg-v2
# Запускаем сервер БД
docker compose up db

# собираем сервис
docker compose build api
# создаём БД и выполняем миграции
docker compose run api bash -c 'python3 staff.py alembic upgrade head'

# генерируем ключевую пару
docker compose run api sh generate-keys.sh

# запускаем АПИ
docker compose up api
# проверяем статус сервиса, например в браузере http://localhost:8000/docs
```
#### если [SQLite]: 
с версии 1.0.0 поддержка [SQLite] не гарантируется 
```shell
# собираем сервис
docker compose build api

# генерируем ключевую пару
docker compose run api sh generate-keys.sh

# создаём БД и выполняем миграции
docker compose run api bash -c 'python3 staff.py alembic upgrade head'

# запускаем АПИ
docker compose up api
# проверяем статус сервиса, например в браузере http://localhost:8000/docs
```
### Добавление первого суперпользователя
Первого пользователя можно добавить автоматически определив соответствующие переменные (см. template.env)
или выполнив команды:
```shell
# входим в контейнер с апи
docker exec -it auth-api-v2 bash
# добавляем пользователя
python3 createsuperuser.py

# добавляем пользователя 
./src/django_space/manage.py migrate
```
{% 
include 'links.md'
rewrite-relative-urls=false
%}
